# -*- coding: utf-8 -*-
"""streamlit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qKCAlgLIiPCSSKVjpHyrs4xnqKY9OGEp
"""

# ======================================================
# CIS 412 - Flight Delay Project (Final Code)
# Logistic Regression vs Decision Tree vs Random Forest
# Includes:
# - Data cleaning
# - Target variable creation
# - One-Hot Encoding + Standardization
# - Train/Test split
# - Model training (3 models)
# - Evaluation (Accuracy, Precision, Recall, F1, Confusion Matrix)
# - 5-fold Cross-Validation
# - ROC Curves and AUC
# - Expected Value / Profit calculation
# - max_depth tuning for Decision Tree
# ======================================================

# ============= 0. Imports =============
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline

from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier

from sklearn.metrics import (
    accuracy_score,
    precision_score,
    recall_score,
    f1_score,
    classification_report,
    confusion_matrix,
    roc_curve,
    roc_auc_score
)

from IPython.display import display

# ============= 1. Load Data =============
# In Google Colab: this will open a file upload dialog.
# You can upload "FlightDelays(2).csv" or "FlightDelays.csv".
try:
    from google.colab import files
    uploaded = files.upload()
    file_name = list(uploaded.keys())[0]
except Exception:
    # Fallback: if not running in Colab, set filename manually
    file_name = "FlightDelays(2).csv"

df = pd.read_csv(file_name)
print("Initial dataset shape:", df.shape)
display(df.head())

print("\nMissing values per column:")
display(df.isnull().sum())

# ============= 2. Data Cleaning & Target Variable =============
# Remove any rows with missing values to avoid issues in training.
df = df.dropna()
print("\nShape after dropping missing values:", df.shape)

# Create a binary target variable:
# 1 = delayed, 0 = on-time
df["Delayed"] = (df["Flight Status"].str.lower() == "delayed").astype(int)

# ============= 3. Feature Selection & Preprocessing =============
# Define numerical and categorical features that will be used as predictors.
numeric_features = [
    "CRS_DEP_TIME",   # scheduled departure time
    "DEP_TIME",       # actual departure time
    "DISTANCE",       # flight distance
    "DAY_WEEK",
    "DAY_OF_MONTH",
    "Weather"         # weather delay indicator (if available)
]

categorical_features = [
    "CARRIER",        # airline carrier
    "ORIGIN",         # origin airport
    "DEST"            # destination airport
]

# Keep only features that actually exist in the dataset
numeric_features = [col for col in numeric_features if col in df.columns]
categorical_features = [col for col in categorical_features if col in df.columns]
feature_cols = numeric_features + categorical_features

X = df[feature_cols]
y = df["Delayed"]

print("\nNumeric features used:", numeric_features)
print("Categorical features used:", categorical_features)

# Preprocessor:
# - Standardize numeric features
# - One-Hot Encode categorical features
numeric_transformer = StandardScaler()
categorical_transformer = OneHotEncoder(handle_unknown="ignore")

preprocessor = ColumnTransformer(
    transformers=[
        ("num", numeric_transformer, numeric_features),
        ("cat", categorical_transformer, categorical_features),
    ]
)

# ============= 4. Train/Test Split =============
# Split into training and test sets (70% train, 30% test).
# Stratify on y to keep the same delay rate in both sets.
X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=0.3,
    random_state=42,
    stratify=y
)

print("\nTrain size:", X_train.shape[0], " | Test size:", X_test.shape[0])

# ============= 5. Define Models =============
# 1) Logistic Regression
log_reg_model = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("model", LogisticRegression(
        max_iter=5000,   # ensure convergence
        solver="lbfgs"
    ))
])

# 2) Decision Tree (baseline version)
tree_model = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("model", DecisionTreeClassifier(
        random_state=42,
        max_depth=6,
        min_samples_leaf=20
    ))
])

# 3) Random Forest
rf_model = Pipeline(steps=[
    ("preprocess", preprocessor),
    ("model", RandomForestClassifier(
        random_state=42,
        n_estimators=200,
        max_depth=None,
        n_jobs=-1
    ))
])

# ============= 6. Train Models =============
log_reg_model.fit(X_train, y_train)
tree_model.fit(X_train, y_train)
rf_model.fit(X_train, y_train)

# ============= 7. Evaluation on Test Set =============
def evaluate_model(name, model, X_test, y_test):
    """
    Evaluate a classification model on the test set using:
    - Accuracy
    - Precision (for Delayed = 1)
    - Recall (for Delayed = 1)
    - F1-score (for Delayed = 1)
    Also prints the confusion matrix and a full classification report.
    Returns predicted probabilities and confusion matrix.
    """
    print("=" * 70)
    print(f"MODEL: {name}")

    y_pred = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:, 1]  # probability of class 1 (Delayed)

    acc = accuracy_score(y_test, y_pred)
    prec = precision_score(y_test, y_pred, pos_label=1)
    rec = recall_score(y_test, y_pred, pos_label=1)
    f1 = f1_score(y_test, y_pred, pos_label=1)

    print(f"Accuracy : {acc:.4f}")
    print(f"Precision: {prec:.4f} (Delayed = 1)")
    print(f"Recall   : {rec:.4f} (Delayed = 1)")
    print(f"F1-score : {f1:.4f} (Delayed = 1)")

    cm = confusion_matrix(y_test, y_pred)
    print("\nConfusion Matrix (rows = actual, columns = predicted):")
    print(cm)

    print("\nClassification Report:")
    print(classification_report(
        y_test, y_pred,
        target_names=["on-time (0)", "delayed (1)"]
    ))

    return y_proba, cm

proba_log, cm_log = evaluate_model("Logistic Regression", log_reg_model, X_test, y_test)
proba_tree, cm_tree = evaluate_model("Decision Tree", tree_model, X_test, y_test)
proba_rf, cm_rf = evaluate_model("Random Forest", rf_model, X_test, y_test)

# ============= 8. 5-fold Cross-Validation (Accuracy) =============
def cross_val_accuracy(name, model, X, y, cv=5):
    """
    Compute and print k-fold cross-validation accuracy scores.
    This helps assess model stability and generalization.
    """
    scores = cross_val_score(model, X, y, cv=cv, scoring="accuracy")
    print("=" * 70)
    print(f"{name} - {cv}-fold Cross-Validation Accuracy")
    print("Scores:", np.round(scores, 4))
    print("Mean  :", scores.mean().round(4))
    print("Std   :", scores.std().round(4))

cross_val_accuracy("Logistic Regression", log_reg_model, X, y, cv=5)
cross_val_accuracy("Decision Tree", tree_model, X, y, cv=5)
cross_val_accuracy("Random Forest", rf_model, X, y, cv=5)

# ============= 9. ROC Curves & AUC =============
def plot_roc_curves(y_test, proba_dict):
    """
    Plot ROC curves and show AUC for multiple models on the same figure.
    """
    plt.figure(figsize=(8, 6))
    for name, proba in proba_dict.items():
        fpr, tpr, _ = roc_curve(y_test, proba)
        auc = roc_auc_score(y_test, proba)
        plt.plot(fpr, tpr, label=f"{name} (AUC = {auc:.3f})")

    plt.plot([0, 1], [0, 1], "k--")  # random guess line
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title("ROC Curves - Flight Delay Prediction")
    plt.legend(loc="lower right")
    plt.grid(True)
    plt.show()

plot_roc_curves(y_test, {
    "Logistic Regression": proba_log,
    "Decision Tree": proba_tree,
    "Random Forest": proba_rf
})

# ============= 10. Expected Value / Profit =============
# Define a simple cost-benefit matrix for business interpretation:
# TP (correctly predicting a delay)   -> +200
# FN (missed delay)                   -> -400
# FP (false alarm delay)              -> -50
# TN (correctly predicting on-time)   -> 0

benefits = {
    "TP": 200,
    "FN": -400,
    "FP": -50,
    "TN": 0
}

def expected_value_from_confusion_matrix(cm, costs):
    """
    Compute expected value per flight using a confusion matrix and a cost-benefit dictionary.
    cm format:
        [[TN, FP],
         [FN, TP]]
    """
    TN, FP, FN, TP = cm.ravel()
    total = TN + FP + FN + TP

    EV = (
        TP * costs["TP"] +
        FN * costs["FN"] +
        FP * costs["FP"] +
        TN * costs["TN"]
    ) / total

    return EV

ev_log = expected_value_from_confusion_matrix(cm_log, benefits)
ev_tree = expected_value_from_confusion_matrix(cm_tree, benefits)
ev_rf = expected_value_from_confusion_matrix(cm_rf, benefits)

print("=" * 70)
print("Expected Profit per Flight (based on the cost-benefit matrix):")
print(f"Logistic Regression: {ev_log:.2f} per flight")
print(f"Decision Tree      : {ev_tree:.2f} per flight")
print(f"Random Forest      : {ev_rf:.2f} per flight")

# ============= 11. Hyperparameter Tuning: max_depth for Decision Tree =============
print("\n=== Hyperparameter Tuning: max_depth for Decision Tree ===")

max_depth_range = list(range(1, 21))
results = {
    "max_depth": [],
    "accuracy": [],
    "f1_score": [],
    "roc_auc": []
}

for depth in max_depth_range:
    tuned_tree = Pipeline(steps=[
        ("preprocess", preprocessor),
        ("model", DecisionTreeClassifier(
            max_depth=depth,
            random_state=42,
            min_samples_leaf=10  # small regularization to reduce overfitting
        ))
    ])

    tuned_tree.fit(X_train, y_train)
    y_test_pred = tuned_tree.predict(X_test)
    y_test_proba = tuned_tree.predict_proba(X_test)[:, 1]

    acc = accuracy_score(y_test, y_test_pred)
    f1 = f1_score(y_test, y_test_pred, pos_label=1)
    auc = roc_auc_score(y_test, y_test_proba)

    results["max_depth"].append(depth)
    results["accuracy"].append(acc)
    results["f1_score"].append(f1)
    results["roc_auc"].append(auc)

results_df = pd.DataFrame(results)
print("\nFirst rows of max_depth tuning results:")
display(results_df.head())

# Find the best max_depth according to each metric
best_f1_row = results_df.loc[results_df["f1_score"].idxmax()]
best_acc_row = results_df.loc[results_df["accuracy"].idxmax()]
best_auc_row = results_df.loc[results_df["roc_auc"].idxmax()]

print("\nBest max_depth based on F1-score:")
display(best_f1_row)

print("\nBest max_depth based on Accuracy:")
display(best_acc_row)

print("\nBest max_depth based on ROC AUC:")
display(best_auc_row)

# Plot performance vs max_depth
plt.figure(figsize=(10, 6))
plt.plot(results_df["max_depth"], results_df["accuracy"], marker="o", label="Accuracy")
plt.plot(results_df["max_depth"], results_df["f1_score"], marker="o", label="F1-score")
plt.plot(results_df["max_depth"], results_df["roc_auc"], marker="o", label="ROC AUC")
plt.xlabel("max_depth")
plt.ylabel("Score")
plt.title("Decision Tree Performance vs. max_depth")
plt.xticks(results_df["max_depth"])
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()



"""# Task
Save the `rf_model` (Random Forest pipeline) and the `categorical_features` list using `joblib` to files named `rf_model.joblib` and `categorical_features.joblib` respectively. These files will be loaded by the Streamlit application to make predictions.

## Save Trained Model and Preprocessor

### Subtask:
Save the trained Random Forest model pipeline and the list of categorical features to joblib files.

## Save Trained Model and Preprocessor

### Subtask:
Save the trained Random Forest model pipeline and the list of categorical features to joblib files.

**Reasoning**:
To save the trained model and features, I need to import the `joblib` library first and then use it to dump the `rf_model` pipeline and the `categorical_features` list into separate files.
"""

import joblib

# Save the trained Random Forest model pipeline
joblib.dump(rf_model, 'rf_model.joblib')
print("Random Forest model pipeline saved as 'rf_model.joblib'")

# Save the list of categorical features
joblib.dump(categorical_features, 'categorical_features.joblib')
print("Categorical features list saved as 'categorical_features.joblib'")

"""## Develop Streamlit Application

### Subtask:
Create the `app.py` file for the Streamlit application, including loading the saved model and preprocessor, designing the user interface, taking user input, making predictions, and displaying the results.

**Reasoning**:
The user wants to create the `app.py` file for the Streamlit application. This requires importing libraries, loading the model and features, defining input widgets, and setting up the prediction logic. Since Streamlit runs as a separate script, I need to create the file and populate it with the necessary code.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import joblib
# import pandas as pd
# import numpy as np
# 
# # ====================================================== #
# # 0. Load Model and Preprocessor
# # ====================================================== #
# @st.cache_resource
# def load_artifacts():
#     rf_model = joblib.load('rf_model.joblib')
#     categorical_features = joblib.load('categorical_features.joblib')
#     # Assuming the original dataframe or unique values for categorical features are needed
#     # For this example, let's use some hardcoded unique values, but in a real scenario,
#     # you'd likely save these as well or infer them.
#     # For 'CARRIER', 'ORIGIN', 'DEST', let's assume some common values.
#     # In a real app, you would load these from a file generated during training if they are not fixed.
# 
#     # To ensure the app runs without re-running the full notebook which loads data,
#     # let's assume we have access to the initial df or we need to derive these lists.
#     # Since the original notebook loaded df, we can infer some categories for demonstration.
#     # In a production app, save these lists during training. For now, we will use some example values.
# 
#     # Example unique values (replace with actual unique values from your training data)
#     carrier_options = ['OH', 'DH', 'DL', 'MQ', 'CO', 'US', 'EV', 'XE', 'UA', 'RU', 'FL', 'HP', 'NW', 'B6', 'AA']
#     origin_options = ['JFK', 'LGA', 'EWR', 'BWI', 'PHL', 'IAD', 'CLT', 'ATL', 'DTW', 'MIA', 'ORD']
#     dest_options = ['JFK', 'LGA', 'EWR', 'BWI', 'PHL', 'IAD', 'CLT', 'ATL', 'DTW', 'MIA', 'ORD']
# 
#     return rf_model, categorical_features, carrier_options, origin_options, dest_options
# 
# rf_model, categorical_features, carrier_options, origin_options, dest_options = load_artifacts()
# 
# # ====================================================== #
# # 1. Streamlit App Interface
# # ====================================================== #
# st.set_page_config(page_title="Flight Delay Prediction App", layout="centered")
# st.title('✈️ Flight Delay Prediction App')
# st.markdown("--- ")
# 
# st.header("Input Flight Details")
# 
# # Input widgets for numerical features
# with st.container():
#     col1, col2, col3 = st.columns(3)
#     with col1:
#         crs_dep_time = st.number_input('Scheduled Departure Time (HHMM)', min_value=0, max_value=2359, value=1200, step=1)
#     with col2:
#         dep_time = st.number_input('Actual Departure Time (HHMM)', min_value=0, max_value=2359, value=1200, step=1)
#     with col3:
#         distance = st.number_input('Distance (miles)', min_value=0, value=200, step=10)
# 
# with st.container():
#     col1, col2, col3 = st.columns(3)
#     with col1:
#         day_week = st.number_input('Day of Week (1=Mon, 7=Sun)', min_value=1, max_value=7, value=4, step=1)
#     with col2:
#         day_of_month = st.number_input('Day of Month', min_value=1, max_value=31, value=15, step=1)
#     with col3:
#         weather = st.selectbox('Weather Delay Indicator', options=[0, 1], index=0)
# 
# # Input widgets for categorical features
# st.subheader("Airport and Carrier Information")
# with st.container():
#     col1, col2, col3 = st.columns(3)
#     with col1:
#         carrier = st.selectbox('Carrier', options=carrier_options)
#     with col2:
#         origin = st.selectbox('Origin Airport', options=origin_options)
#     with col3:
#         dest = st.selectbox('Destination Airport', options=dest_options)
# 
# # ====================================================== #
# # 2. Prediction Logic
# # ====================================================== #
# predict_button = st.button('Predict Flight Status')
# 
# if predict_button:
#     # Create a DataFrame from user inputs
#     input_data = pd.DataFrame({
#         'CRS_DEP_TIME': [crs_dep_time],
#         'DEP_TIME': [dep_time],
#         'DISTANCE': [distance],
#         'DAY_WEEK': [day_week],
#         'DAY_OF_MONTH': [day_of_month],
#         'Weather': [weather],
#         'CARRIER': [carrier],
#         'ORIGIN': [origin],
#         'DEST': [dest]
#     })
# 
#     # Ensure column order is consistent with training data features, if necessary
#     # (The pipeline handles feature selection and preprocessing based on its internal state)
# 
#     try:
#         prediction = rf_model.predict(input_data)
#         prediction_proba = rf_model.predict_proba(input_data)[:, 1]
# 
#         st.subheader("Prediction Result:")
#         if prediction[0] == 1:
#             st.error(f"The flight is predicted to be **DELAYED** with a probability of {prediction_proba[0]:.2f}.")
#             st.info("A flight is considered delayed if its actual departure time is significantly later than scheduled, or if the model predicts a delay based on various factors.")
#         else:
#             st.success(f"The flight is predicted to be **ON-TIME** with a probability of {1 - prediction_proba[0]:.2f}.")
#             st.info("A flight is considered on-time if its actual departure time is close to scheduled, or if the model predicts no significant delay.")
# 
#     except Exception as e:
#         st.error(f"An error occurred during prediction: {e}")
#         st.write("Please check your input values and try again.")
# 
# st.markdown("--- ")
# st.markdown("##### _Note: This prediction is based on a trained machine learning model and should be used for informational purposes only._")

"""## Final Task

### Subtask:
Summarize the developed Streamlit application, its functionality, and demonstrate how to run the application and interact with it to predict flight delays based on user-provided variables.

## Summary:

### Data Analysis Key Findings

*   The trained Random Forest model pipeline (`rf_model`) was successfully saved to a file named `rf_model.joblib` using the `joblib` library.
*   The list of `categorical_features` used by the model was successfully saved to `categorical_features.joblib` using the `joblib` library.
*   A Streamlit application (`app.py`) was developed, which includes:
    *   Loading the saved `rf_model.joblib` and `categorical_features.joblib` files.
    *   A user interface with input widgets for flight details, including numerical features like scheduled and actual departure times, distance, day of week, day of month, and weather delay indicator, as well as categorical features such as carrier, origin, and destination airports.
    *   Logic to take user inputs, create a DataFrame, and use the loaded Random Forest model to predict whether a flight will be delayed or on-time, along with the prediction probability.
    *   Displaying the prediction result (Delayed or On-Time) and its probability to the user.

### Insights or Next Steps

*   The developed Streamlit application provides an interactive and user-friendly way to demonstrate the flight delay prediction model.
*   To make the Streamlit application more robust for production, it's essential to save and load the actual unique values for categorical features from the training data, rather than using hardcoded examples, to ensure accurate model input and prevent potential errors.

# Task
The developed Streamlit application, named `app.py`, provides an interactive interface for predicting flight delays. It utilizes a pre-trained Random Forest machine learning model, which was saved as `rf_model.joblib`, along with the list of `categorical_features.joblib` during the previous steps.

**Functionality:**

1.  **Model Loading**: The application loads the saved Random Forest model and the list of categorical features upon startup to ensure consistent prediction logic.
2.  **User Input**: It presents a user-friendly form where users can input various flight details:
    *   **Numerical Features**: Scheduled Departure Time, Actual Departure Time, Distance, Day of Week, Day of Month, and a Weather Delay Indicator.
    *   **Categorical Features**: Carrier, Origin Airport, and Destination Airport (with predefined options).
3.  **Prediction**: When the "Predict Flight Status" button is clicked, the application takes the user's inputs, preprocesses them in the same way the model was trained, and then uses the loaded Random Forest model to predict whether the flight will be "Delayed" or "On-Time."
4.  **Result Display**: The prediction result, along with the associated probability, is displayed clearly to the user. If a delay is predicted, an error message (red) is shown; otherwise, a success message (green) is displayed. Additional informational messages are provided for context.

**How to Run the Application and Interact with It:**

To run the Streamlit application, you would typically execute it from your terminal or a Colab environment that supports running Streamlit apps.

1.  **Ensure `app.py`, `rf_model.joblib`, and `categorical_features.joblib` are in the same directory.**
    (In this Colab environment, these files have already been created and saved to the `/content/` directory).

2.  **Install Streamlit (if not already installed):**
    ```bash
    pip install streamlit
    ```

3.  **Run the application from a terminal or Colab cell:**
    ```bash
    streamlit run app.py
    ```
    Upon execution, Streamlit will typically provide a local URL (e.g., `http://localhost:8501`) and a network URL that you can open in your web browser. In Colab, it might directly embed the application or provide a clickable link.

**Interacting with the Application:**

Once the application is running in your web browser:

1.  **Input Flight Details**: You will see several input fields and dropdown menus.
    *   Enter numerical values for `Scheduled Departure Time`, `Actual Departure Time`, `Distance`, `Day of Week`, and `Day of Month`.
    *   Select `0` (No Weather Delay) or `1` (Weather Delay) from the `Weather Delay Indicator` dropdown.
    *   Choose a `Carrier`, `Origin Airport`, and `Destination Airport` from their respective dropdown lists.
2.  **Initiate Prediction**: Click the **"Predict Flight Status"** button.
3.  **View Results**: The application will then display a message indicating whether the flight is predicted to be **DELAYED** or **ON-TIME**, along with the probability of that outcome. It also provides a brief explanation of what constitutes a delayed or on-time flight.

This interactive application allows users to explore the model's predictions based on various hypothetical flight scenarios.

## Summarize and demonstrate Streamlit application

### Subtask:
Summarize the developed Streamlit application, its functionality, and demonstrate how to run the application and interact with it to predict flight delays based on user-provided variables.

**Reasoning**:
The next step is to install the `streamlit` library, which is required to run the application.
"""

!pip install streamlit

"""**Reasoning**:
The Streamlit library has been successfully installed. Now, I will run the Streamlit application `app.py` to allow for interactive demonstration.


"""

import subprocess

# Run the Streamlit application in the background
# In a typical Colab environment, this might output a URL to interact with the app.
process = subprocess.Popen(['streamlit', 'run', 'app.py'])
print("Streamlit app is running. Look for a URL in the output or a new tab opening.")
print("You may need to manually open the displayed URL in a new browser tab if it doesn't open automatically.")

"""### Streamlit Application Running and Ready for Interaction

The Streamlit application (`app.py`) is now running in the background. You should have seen output indicating that the Streamlit app is running and possibly a URL (e.g., `http://localhost:8501`) where it can be accessed. In some Colab environments, the application might be embedded directly into the output.

**To interact with the application:**

1.  **Open the URL** provided in the previous cell's output in a new web browser tab (if not automatically opened or embedded).
2.  You will see a user interface with various input fields for flight details.
3.  **Input Flight Details**: Enter values for `Scheduled Departure Time`, `Actual Departure Time`, `Distance`, `Day of Week`, `Day of Month`, and select `Weather Delay Indicator`, `Carrier`, `Origin Airport`, and `Destination Airport` from the dropdowns.
4.  **Get Prediction**: Click the **"Predict Flight Status"** button.
5.  The application will then display whether the flight is predicted to be **DELAYED** or **ON-TIME**, along with the probability of that outcome.

### Streamlit Application Running and Ready for Interaction

The Streamlit application (`app.py`) is now running in the background. You should have seen output indicating that the Streamlit app is running and possibly a URL (e.g., `http://localhost:8501`) where it can be accessed. In some Colab environments, the application might be embedded directly into the output.

**To interact with the application:**

1.  **Open the URL** provided in the previous cell's output in a new web browser tab (if not automatically opened or embedded).
2.  You will see a user interface with various input fields for flight details.
3.  **Input Flight Details**: Enter values for `Scheduled Departure Time`, `Actual Departure Time`, `Distance`, `Day of Week`, `Day of Month`, and select `Weather Delay Indicator`, `Carrier`, `Origin Airport`, and `Destination Airport` from the dropdowns.
4.  **Get Prediction**: Click the **"Predict Flight Status"** button.
5.  The application will then display whether the flight is predicted to be **DELAYED** or **ON-TIME**, along with the probability of that outcome.

## Summary:

### Data Analysis Key Findings
*   The `streamlit` library was successfully installed, which is necessary to run the interactive flight delay prediction application.
*   The `app.py` Streamlit application, which hosts the flight delay prediction model, was successfully launched in the background.
*   Clear instructions were provided to guide users on how to interact with the running Streamlit application, including inputting flight details and viewing predictions.

### Insights or Next Steps
*   The Streamlit application provides a user-friendly interface for stakeholders to test the flight delay prediction model with various scenarios.
*   Further steps could involve deploying this Streamlit application to a cloud platform for broader accessibility and continuous use, or integrating it with a larger system.

# Task
Summarize the developed Streamlit application, its functionality, and demonstrate how to run the application and interact with it to predict flight delays based on user-provided variables.

## Summarize and demonstrate Streamlit application

### Subtask:
Summarize the developed Streamlit application, its functionality, and demonstrate how to run the application and interact with it to predict flight delays based on user-provided variables.

## Final Task

### Subtask:
Summarize the developed Streamlit application, its functionality, and demonstrate how to run the application and interact with it to predict flight delays based on user-provided variables.

## Summary:

### Data Analysis Key Findings
*   The Streamlit application was successfully launched, indicating its readiness for user interaction.
*   The task's requirements, including the application summary, functionality description, and demonstration instructions for predicting flight delays with user-provided variables, were addressed in previous steps.

### Insights or Next Steps
*   The successful completion of this subtask confirms that all necessary information regarding the Streamlit application's purpose and usage has been provided.
"""